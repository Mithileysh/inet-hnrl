/***************************************************************************
 * file:        WifiRobotMobility.cc
 *
 * author:      Steffen Sroka
 *
 * copyright:   (C) 2004 Telecommunication Networks Group (TKN) at
 *              Technische Universitaet Berlin, Germany.
 *
 *              This program is free software; you can redistribute it
 *              and/or modify it under the terms of the GNU General Public
 *              License as published by the Free Software Foundation; either
 *              version 2 of the License, or (at your option) any later
 *              version.
 *              For further information see file COPYING
 *              in the top level directory
 ***************************************************************************
 * part of:     framework implementation developed by tkn
 **************************************************************************/

#include "WifiRobotMobility.h"
#include "FWMath.h"

Define_Module(WifiRobotMobility)
;

/**
 * Reads the updateInterval and the velocity
 *
 * If the host is not stationary it calculates a random position and
 * schedules a timer to trigger the first movement
 */
void WifiRobotMobility::initialize(int stage)
{
	BasicMobility::initialize(stage);

	EV<< "initializing WifiRobotMobility stage " << stage << endl;

	if (stage == 0)
	{
		updateInterval = par("updateInterval");
		vHost = par("vHost");

		// if the initial speed is lower than 0, the node is stationary
		stationary = (vHost <= 0);

		//calculate the target position of the host if the host moves
		if (!stationary)
		{
			setTargetPosition();
			//host moves the first time after some random delay to avoid synchronized movements
			scheduleAt(simTime() + uniform(0, updateInterval), new cMessage("move"));
		}
	}
}

void WifiRobotMobility::handleMessage(cMessage * msg)
{
	if (msg->isSelfMessage())
	{
		handleSelfMsg(msg);
	}
	else
	{
		if (dynamic_cast<AirFrameExtended *> (msg) != NULL)
		{
			handleLowerMsg(check_and_cast<AirFrameExtended *> (msg));
		}
		else
		{
			error("WifiRobotMobility module can receive only AirFramesExtended from the PHY layer");
		}
	}
}

/**
 * The only self message possible is to indicate a new movement. If
 * host is stationary this function is never called.
 */
void WifiRobotMobility::handleSelfMsg(cMessage* msg)
{
	move();
	updatePosition();
	scheduleAt(simTime() + updateInterval, msg);
}

/**
 * Handle an Ieee80211BeaconFrame from the PHY layer.
 */
void WifiRobotMobility::handleLowerMsg(AirFrameExtended *airFrame)
{
	cMessage *msg = airFrame->decapsulate();

	if (dynamic_cast<Ieee80211BeaconFrame *>(msg) != NULL)
	{
		// handles only beacon frames now

		Ieee80211BeaconFrame *beacon = check_and_cast<Ieee80211BeaconFrame *>(msg);
		std::string ssid = (beacon->getBody()).getSSID();

		// calculate a distance from the sender position (*** not realistic model ***)
		const Coord& framePos = airFrame->getSenderPos();
		double distance = pos.distance(framePos);

		EV << "Frame received from " << ssid.c_str() << " located at " << distance << endl;

		// TODO: Calculate a distance based on the received power

//		double carrierFrequency = airFrame->getCarrierFrequency();
//		double powerReceived = airFrame->getPowRec();
//		double powerSent = airFrame->getPSend();
//		double snr = airFrame->getSnr();
//
//		EV<< "Frame received from " << ssid.c_str() << ":" << endl;
//		EV << "- Power received = " << powerReceived << endl;
//		EV << "- Power sent = " << powerSent << endl;
//		EV << "- SNR = " << snr << endl;
//
//	    const double speedOfLight = 300000000.0;
//	    double waveLength = speedOfLight / carrierFrequency;
//		double distance = pow(waveLength*waveLenth*powerSent/(16*M_PI*powerReceived), -pathLossAlpha);


		// TODO: Implement localization algorithm here.


	}

	delete msg;
	delete airFrame;
}

/**
 * Calculate a new random position and the number of steps the host
 * needs to reach this position
 */
void WifiRobotMobility::setTargetPosition()
{
	targetPos = getRandomPosition();
	double distance = pos.distance(targetPos);
	double totalTime = distance / vHost;
	numSteps = FWMath::round(totalTime / updateInterval);

	stepSize = (targetPos - pos) / numSteps;

	step = 0;

	EV<< "distance=" << distance << " xpos= " << targetPos.x << " ypos=" <<targetPos.y
        << "totalTime=" << totalTime << " numSteps=" << numSteps << " vHost=" << vHost << endl;
}

/**
 * Move the host if the destination is not reached yet. Otherwise
 * calculate a new random position
 */
void WifiRobotMobility::move()
{
	step++;

	if (step <= numSteps)
	{
		EV<< "stepping forward. step #=" << step << " xpos= " << pos.x << " ypos="<< pos.
            y << endl;

        pos += stepSize;
    }
    else
    {
        EV << "destination reached.\n xpos= " << pos.x << " ypos=" << pos.y << endl;

        setTargetPosition();
    }
}
