// $Id$
//-------------------------------------------------------------------------------
//	HybridPonMac.cpp --
//
//	This file implements 'HybridPonMac' class in a hybrid TDM/WDM-PON ONU.
//
//	Copyright (C) 2009 Kyeong Soo (Joseph) Kim
//-------------------------------------------------------------------------------


// #define DEBUG_SLOT_MGR


#include "HybridPonMac.h"


// Register modules.
Define_Module(HybridPonMac);


//------------------------------------------------------------------------------
// HybridPonMac::receiveFrameFromUni --
//
//		receives a frame from a UNI.
//
// Arguments:
// 		cPacket *frame;
//
// Results:
//		If there is enough space, it is added to a FIFO.
//      Otherwise, it is dropped.
//------------------------------------------------------------------------------

void HybridPonMac::receiveFrameFromUni(cPacket *frame)
{
#ifdef DEBUG_PONMAC
    ev << getFullPath() << ": A frame from UNI received" << endl;
#endif

//     if ( busyQueue + frame->getBitLength() + ETH_OVERHEAD_SIZE <= queueSize) {
//         EthFrame *ethFrame = new EthFrame();
//         ethFrame->setBitLength(ETH_OVERHEAD_SIZE);
//         ethFrame->encapsulate(pkt);
//         busyQueue += ethFrame->getBitLength();
//         queue.insert( ethFrame );

#ifdef DEBUG_PONMAC
        ev << getFullPath() << ": busyQueue = " << busyQueue << endl;
#endif
//     }
//     else {
//         monitor->recordLossStats(frame->getSrcAddress(), frame->getDstnAddress(), frame->getBitLength() );
//         delete frame;

#ifdef DEBUG_PONMAC
        ev << getFullPath() << ": A frame from UNI dropped!" << endl;
#endif
//    }
}


//------------------------------------------------------------------------------
// HybridPonMac::receiveDataFromPon --
//
//		receives a PON frame from an OLT including downstream data.
//
// Arguments:
// 		HybridPonFrame *frame;
//
// Results:
//		Ethernet frames inside the PON frame have been sent to
//      an IP packet sink.
//------------------------------------------------------------------------------

void HybridPonMac::receiveDataFromPon(HybridPonFrame *ponFrameFromOlt)
{
#ifdef DEBUG_PONMAC
    ev << getFullPath() << ": PON frame received with downstream data" << endl;
#endif

    cQueue &ethFrameQueue = ponFrameFromOlt->getEncapsulatedEthFrames();
    while(!ethFrameQueue.empty()) {
        EthFrame *ethFrame = (EthFrame *)ethFrameQueue.pop();
        IpPacket *pkt = (IpPacket *)ethFrame->decapsulate();
        send(pkt, "toPacketSink");
        delete (EthFrame *) ethFrame;
    }
    delete ponFrameFromOlt;
}


//------------------------------------------------------------------------------
// HybridPonMac::receiveGrantFromPon --
//
//		receives a PON frame from an OLT including a grant for ONU upstream
//      data.
//
// Arguments:
// 		HybridPonFrame *frame;
//
// Results:
//		A new PON upstream frame has been created and sent back to the OLT.
//------------------------------------------------------------------------------

void HybridPonMac::receiveGrantFromPon(HybridPonFrame *ponFrameFromOlt)
{
#ifdef DEBUG_PONMAC
    ev << getFullPath() << ": PON frame received with grant = " << ponFrameFromOlt->getGrant() << endl;
#endif

    HybridPonFrame *ponFrameToOlt = new HybridPonFrame("", PON_FRAME);
    ponFrameToOlt->setLambda(lambda);
    cQueue &ethFrameQueue = ponFrameToOlt->getEncapsulatedEthFrames();
    int encapsulatedEthFramesSize = 0;

    // First, check the grant size for upstream data to determine
    // if it's for polling (request) only or polling and upstream data.
	int grant = ponFrameFromOlt->getGrant();
    if (grant > 0) {
        // It's for both polling (request) and upstream data.

        if (queue.empty() != true) {
            EthFrame *ethFrame = (EthFrame *)queue.front();
            while ( grant >= (ethFrame->getBitLength() + encapsulatedEthFramesSize) ) {
                // The length of the 1st Ethernet frame in the FIFO queue is less than or
                // equal to the remaining data grant.

                ethFrame = (EthFrame *)queue.pop();
                encapsulatedEthFramesSize += ethFrame->getBitLength();
                busyQueue -= ethFrame->getBitLength();
                ethFrameQueue.insert(ethFrame);

                if (queue.empty() == true) {
                    break;
                }
                else {
                    ethFrame = (EthFrame *)queue.front();
                }
            }   // end of while loop
        }
    }

    // Set request and other fields of the new upstream PON frame.
    ponFrameToOlt->setRequest(busyQueue);
    ponFrameToOlt->setLambda(lambda);
    ponFrameToOlt->setBitLength(PREAMBLE_SIZE + DELIMITER_SIZE + REQUEST_SIZE + encapsulatedEthFramesSize);

#ifdef DEBUG_PONMAC
    ev << getFullPath() << ": PON frame sent upstream with length = " <<
        ponFrameToOlt->getBitLength() << " and request = " << ponFrameToOlt->getRequest() << endl;
#endif

    // Here we don't include transmission delay because in PON,
    // the ONU only modulates incoming CW burst, not receives it as usual.
    send(ponFrameToOlt, "toOlt");

    delete ponFrameFromOlt;
}


//------------------------------------------------------------------------------
// HybridPonMac::initialize --
//
//		initialize member variables.
//
// Arguments:
//
// Results:
//		All member variables have been allocated memory and initialized.
//------------------------------------------------------------------------------

void HybridPonMac::initialize()
{
	lambda = (int) getParentModule()->par("lambda");
	queueSize = par("queueSize");

    busyQueue = 0;

	monitor = (Monitor *) ( gate("toMonitor")->getPathEndGate()->getOwnerModule() );
#ifdef DEBUG_PONMAC
	ev << getFullPath() << ": monitor pointing to module with id = " << monitor->getId() << endl;
#endif
}


//------------------------------------------------------------------------------
// HybridPonMac::handleMessage --
//
//		handles messages by calling appropriate functions for their processing.
//
// Arguments:
// 		cMessage *msg
//
// Results:
//		Simulation starts and runs until it will be terminated by kernel.
//------------------------------------------------------------------------------

void HybridPonMac::handleMessage(cMessage *msg)
{
#ifdef TRACE_MSG
	ev.printf();
	PrintMsg(*msg);
#endif

    switch (msg->getKind()) {

    case IP_PACKET:
        receiveFrameFromUni((cPacket *)msg);
        break;

    case HYBRID_PON_FRAME:
		// Check if the PON frame received is from OLT.
		assert( msg->getArrivalGateId() == findGate("fromOlt") );

        //if (msg->getArrivalGateId() == findGate("fromOlt")) {
        //    // It's a downstream PON frame from the OLT.

		//HybridPonFrame *ponFrameFromOlt = (HybridPonFrame *)msg;
		if ( ((HybridPonFrame *)msg)->getId() == true ) {
			// It's a PON frame with downstream data.
			receiveDataFromPon((HybridPonFrame *)msg);
		}
		else {
			// It's a PON frame with grant.
			receiveGrantFromPon((HybridPonFrame *)msg);
		}

		//}
        break;

    default:
        ev << getFullPath() << ": ERROR: unexpected message kind " << msg->getKind() << "received." << endl;
        delete (cMessage *) msg;
        exit(1);
    }   // end of switch()
}


void HybridPonMac::finish()
{

}
