/***************************************************************************
 * file:        WifiRobotMobility.cc
 *
 * authors:     Sion O'Boyle
 * 				Ramya Sasidharan
 *
 * copyright:   (C) 2004 Telecommunication Networks Group (TKN) at
 *              Technische Universitaet Berlin, Germany.
 *              (C) 2010 School of Engineering at Swansea University,
 *              Wales, UK.
 *
 *              This program is free software; you can redistribute it
 *              and/or modify it under the terms of the GNU General Public
 *              License as published by the Free Software Foundation; either
 *              version 2 of the License, or (at your option) any later
 *              version.
 *              For further information see file COPYING
 *              in the top level directory
 ***************************************************************************
 * part of:     framework implementation developed by tkn
 **************************************************************************/

#include "WifiRobotMobility.h"
#include "FWMath.h"
#include "string.h"
#include <math.h>
#include "ChannelControl.h"

using namespace std;

Define_Module(WifiRobotMobility)
;

/**
 * Reads the updateInterval and the velocity
 *
 * If the host is not stationary it calculates a random position and
 * schedules a timer to trigger the first movement
 */

void WifiRobotMobility::initialize(int stage) {
	BasicMobility::initialize(stage);

	distanceCompare = 1e8;
	distanceCompare2 = 1e8;
	count1 = 0;
	count2 = 0;
	D1 = 0;
	D2 = 0;
	D3 = 0;
	xtar = 579;
	ytar = 380;
	Sumtot = 0;
	xp = 0;
	yp = 0;
	xs = 50;
	ys = 130;
	EV<< "initializing WifiRobotMobility stage " << stage << endl;

	double pathLossAlpha;
	if (stage == 0)
	{
		updateInterval = par("updateInterval");
		vHost = par("vHost");

		// if the initial speed is lower than 0, the node is stationary
		stationary = (vHost <= 0);

		//calculate the target position of the host if the host moves
		if (!stationary)
		{
			setTargetPosition();
			//host moves the first time after some random delay to avoid synchronized movements
			scheduleAt(simTime() + uniform(0, updateInterval), new cMessage("move"));
		}
	}
}

void WifiRobotMobility::handleMessage(cMessage * msg) {
	if (msg->isSelfMessage()) {
		handleSelfMsg(msg);
	} else {
		if (dynamic_cast<AirFrameExtended *> (msg) != NULL) {
			handleLowerMsg(check_and_cast<AirFrameExtended *> (msg));
		} else {
			error(
					"WifiRobotMobility module can receive only AirFramesExtended from the PHY layer");
		}
	}
}

/**
 * The only self message possible is to indicate a new movement. If
 * host is stationary this function is never called.
 */
void WifiRobotMobility::handleSelfMsg(cMessage* msg) {
	//	move();
	updatePosition();
	scheduleAt(simTime() + updateInterval, msg);
}

/**
 * Handle an Ieee80211BeaconFrame from the PHY layer.
 */
void WifiRobotMobility::handleLowerMsg(AirFrameExtended *airFrame) {

	cMessage *msg = airFrame->decapsulate();

	if (dynamic_cast<Ieee80211BeaconFrame *> (msg) != NULL) {
		// handles only beacon frames now
		count1++;
		count2++;
		Ieee80211BeaconFrame *beacon = check_and_cast<Ieee80211BeaconFrame *> (
				msg);
		std::string ssid = (beacon->getBody()).getSSID();

		double carrierFrequency = airFrame->getCarrierFrequency();
		double powerReceived = airFrame->getPowRec();
		double powerSent = airFrame->getPSend();
		double snr = airFrame->getSnr();
		EV<< "Frame received from " << ssid.c_str() << ":" << endl;
		// Ideal power received calculated from the robot
		EV << "- Power received = " << powerReceived << endl;
		EV << "- Power sent = " << powerSent << endl;
		EV << "- SNR = " << snr << endl;

		const double speedOfLight = 300000000.0;
		double waveLength = speedOfLight / carrierFrequency;

		// Convert the powers into dB for inputting into the model
		powerSent = 10 * log(powerSent);
		powerReceived = 10*log(powerReceived);

		// Calculated distance in the basis of gathering the power received and calculating
		// using the parameters of power sent and the wavelength.
		double distance =sqrt((powerSent * waveLength * waveLength / (16 * M_PI * M_PI * powerReceived)));
		EV << "distance = " << distance << endl;
		EV << " ssid is from " << ssid.c_str() << endl;

		// Storing distances with regards to the access point
		if (ssid.compare(0,5, "APOne" ,0,5) == 0)
		{
			D1 = distance;
		}
		else if (ssid.compare(0,5, "APTwo" ,0,5) == 0)
		{
			D2 = distance;
		}
		else
		{
			D3 = distance;
		}
		// Outputting the distance results
		EV << " D1 is " << D1 << " D2 is " << D2 << " D3 is "<< D3 << endl;
		// Only calculating its unknown position when all 3 distances are collected
		//using the Trilateration technique
		if ( count1 == 3 )
		{
			getRandomNoise();
			D1 = D1 + Sumtot;

			getRandomNoise();
			D2 = D2 + Sumtot;

			getRandomNoise();
			D3 = D3 + Sumtot;
			EV << " D1 is " << D1 << " D2 is " << D2 << " D3 is "<< D3 << endl;

			P1 = (pow(D1,2) - pow(D3,2)) - (pow(579,2) - pow(24,2)) - (pow(380,2) - pow(380,2));
			EV << "P1 is " << P1 << endl;

			b = P1 / (2 * -555);
			xj = b;
			EV << " xj is " << xj << endl;

			P2 = (pow(D2,2) - pow(D3,2)) - (pow(579,2) - pow(24,2)) - (pow(19,2) - pow(380,2));

			EV << "P2 is " << P2 << endl;

			a = 2* xj * -555;
			yj = P2 - a;
			yj = yj / (2 * 361);

			EV << " yj is " << yj << endl;
			// finding the best representation of coordinates
			dist = xs - xj;
			dist2 = ys - yj;
			if(dist < distanceCompare && dist2 < distanceCompare2) {
				minx = xj;
				miny = yj;
				distanceCompare = dist;
				distanceCompare2 = dist2;
			}
			// outputting the minimum error of estimated coordinates
			EV << " minx is"<< minx << endl;
			EV << " miny is " << miny << endl;
			EV << " dist is "<< dist << " and dist2 is " << dist2 << endl;

			count1 = 0;
		} // end of if(0 for count1
		// when gathered all 9 packets the function to move is called with added noise
		if (count2 == 9) {
			getRandomNoise();
			move();
			count2 = 0;
			distanceCompare = 1e8;
			distanceCompare2 = 1e8;

		}

	} // end of if()

	delete msg;
	delete airFrame;
}

		/**
		 * Calculate a new random position and the number of steps the host
		 * needs to reach this position
		 */
void WifiRobotMobility::setTargetPosition() {

	targetPos = getTargetPosition();
	double distance = pos.distance(targetPos);
	double totalTime = distance / vHost;
	numSteps = FWMath::round(totalTime / updateInterval);
	stepSize = (targetPos - pos) / numSteps;

	distance = vHost * updateInterval;
	EV<< " distance is equal to " << distance << endl;
	step = 0;

	EV<< "distance=" << distance << " xpos= " << targetPos.x << " ypos=" <<targetPos.y
        << "totalTime=" << totalTime << " numSteps=" << numSteps << " vHost=" << vHost << endl;
}

Coord WifiRobotMobility::getTargetPosition() {
	Coord targetPos;
	targetPos.x = 579;
	targetPos.y = 380;
	return targetPos;
}

Coord WifiRobotMobility::getnewTargetPosition() {
	Coord targetPos;
	targetPos.x = 140;
	targetPos.y = 200;
	return targetPos;
}

Coord WifiRobotMobility::getNewPos() {
	Coord newPos;
	newPos.x = 579;
	newPos.y = 380;
	return newPos;
}
// Generates random numbers but since taking an average get a Gaussian distribution of numbers
void WifiRobotMobility::getRandomNoise() {
	randNoise = 0;
	SumRD = 0;
	RN = 1;
	for (RN = 1; RN <= 10; RN++) {
		randNoise = uniform(0, 1);
		SumRD += randNoise;
	}
	Sumtot = SumRD / 10;
	EV<< " sumtot = " << Sumtot << endl;
}
/**
 * Move the host if the destination is not reached yet. Otherwise
 * calculate a new random position
 */
void WifiRobotMobility::move() {
	step++;

	if (step <= numSteps) {
		EV<< " before pos.x was " << pos.x << endl;
		EV << " before pos.y was " << pos.y << endl;

		xnew = pos.x + ((xtar - minx)/numSteps);
		ynew = pos.y + ((ytar - miny)/numSteps);

		EV<< " before noise added position was x= " << xnew << "and y =  " <<ynew << endl;
		newPos.x =  xnew + Sumtot;
		newPos.y = ynew + Sumtot;

		pos.x = newPos.x;
		xs = pos.x;
		EV << "xs is =  " << xs << endl;
		EV << " pos.x is " << pos.x << endl;

		pos.y = newPos.y;
		ys = pos.y;
		EV << "pos.y is " << pos.y << endl;
		EV << "pos = " << pos << endl;
		// makes sure the robot stays within the playground region
		getTargetPosition();
		if (pos.x >= getPlaygroundSizeX()){
			 pos.x = 2*getPlaygroundSizeX() - pos.x;
	        targetPos.x = 2*getPlaygroundSizeY() - targetPos.x;
		}
		if (pos.y >= getPlaygroundSizeY())
		    {
		        pos.y = 2*getPlaygroundSizeY() - pos.y;
		        targetPos.y = 2*getPlaygroundSizeY() - targetPos.y;
		    }
		getTargetPosition();
		if(pos.x >= targetPos.x && pos.y >= targetPos.y){
			EV << endl << "HOST HAS REACHED TARGET POSITION" << endl << endl;
			EV << "Host is charging" << endl << endl << "Host has Recharged" << endl;
			endSimulation();
		}
		updatePosition();

		EV<< "stepping forward. step #=" << step << " xpos= " << pos.x << " ypos= "<< pos.y << endl;

    }
    else
    {
        EV << "destination reached.\n xpos= " << pos.x << " ypos= " << pos.y << endl;

        setTargetPosition();
    }
}
